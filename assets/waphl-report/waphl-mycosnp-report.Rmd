---
title: "MycoSNP Report"
output:
  pdf_document: default
date: "`r Sys.Date()`"
header-includes: 
- \usepackage{placeins}
---

```{r, results='hide', echo=FALSE, message=FALSE, warning=FALSE}
#--------------- CONFIG ---------------#
if(!tinytex::is_tinytex()){
  tinytex::install_tinytex()
}

library(tidyverse)
library(ggtree)
library(phangorn)
library(knitr)
library(kableExtra)

#--------------- GLOBAL OBJECTS ---------------#
# plot Colors
colors <- c("#E69F00", 
            "#56B4E9", 
            "#009E73", 
            "#F0E442", 
            "#0072B2", 
            "#D55E00", 
            "#CC79A7")

#--------------- METADATA ---------------#
# clade references
meta.clades <- data.frame(sample = c("AR389_SRR14252434_Clade_I",
                              "AR381_SRR3883452_Clade_II",
                              "AR383_SRR3883453_Clade_III",
                              "AR386_SRR3883466_Clade_IV",
                              "AR1097_SRR9007776_Clade_V"),
                   clade = c("I",
                             "II",
                             "III",
                             "IV",
                             "V")
                   )

#--------------- INPUT FILES ---------------#
# Sample QC Report
qcreport_file <- "qc_report.txt"
# VCF quality file
vcfreport_file <- "vcf-qc-report.txt"
# tree files
fasttree_file <- "fasttree_phylogeny.nh"
rapidnj_file <- "rapidnj_phylogeny.nh"
quicksnp_file <- "quicksnp_phylogeny.nwk"
tree_files <- c(fasttree_file, rapidnj_file, quicksnp_file) # tree file list - used as input for functions
# snp matrix file
snpmat_file <- "combined.tsv"
# SnpEff files
snpeff_file <- "combined.csv"

#--------------- FUNCTIONS ---------------#
# QC Report
display_qc <- function(qc_file){
  if(file.exists(qc_file)){
    # load file
    df <- read_tsv(qc_file)
    # select relevant columns
    columns <- colnames(df)
    select_columns <- columns[grep(columns, pattern = "Before Trimming", invert = T)]
    df <- df[,select_columns] %>%
      select(-'Reference Length Coverage After Trimming', 
             -"Unpaired Reads After Trimming")
    # simply column names
    colnames(df) <- str_remove_all(colnames(df), pattern = " After Trimming")
    # report table
    df %>%
      kable(booktabs=T) %>%
      column_spec(2:ncol(df),width = "2cm") %>%
      kable_styling(latex_options=c("striped","scale_down","hold_position")) %>%
      footnote(general = "All values determined using trimmed reads.")
  }
}

# Phylogenetic Trees
make_tree <- function(tree_file){
  # check if tree file exists
  if(file.exists(tree_file)){
    # load tree file and root at longest branch
    tree <- read.tree(tree_file) %>% midpoint()
    # fix name issue introduced by rapidnj
    tree$tip.label <- str_remove_all(tree$tip.label, pattern = "'")
    # create initial plot
    p_tree <- ggtree(tree)%<+% meta.clades+
      geom_tiplab(aes(fill=clade), geom="label", label.size = NA)+
      scale_fill_manual(values = colors, na.value = "white")+
      labs(fill="Clade")
    # adjust plot axis
    p_tree <- p_tree+
      xlim(0,max(p_tree$data$x)*1.5)
    
    n_iso <- p_tree$data %>%
      drop_na() %>%
      nrow()
    # set image dimensions
    wdth <- n_iso/5
    if(wdth < 10){
      wdth <- 10
      }
    hght=n_iso/5
    if(hght < 10){
      hght <- 10
      }
    # save image
    ggsave(plot = p_tree, filename = paste0(tree_file,".jpg"), width = wdth, height = hght, dpi = 300, limitsize = F)
  }
}

display_tree <- function(tree_file){
  image_file <- paste0(tree_file,".jpg")
  if(file.exists(image_file)){
    name <- tree_file %>% str_split(pattern = "_") %>% unlist() %>% .[[1]]
    header <- paste0("\n### ",name)
    cat(header, sep = "\n")
    cat(paste0("![](",image_file,")"), sep="\n")
  }
}

# SNP Distance Matrix
make_matrix <- function(matrix_file, tree_files){
  if(file.exists(matrix_file)){
    snp.dist <- read_tsv(matrix_file) %>%
      pivot_longer(names_to = "iso2", values_to = "snps", 2:ncol(.)) %>%
      rename(iso1 = 'snp-dists 0.8.2') 
    
    if(sum(file.exists(tree_files)) > 1){
      sample_order <- read.tree(tree_files[1]) %>% 
        midpoint() %>%
        ggtree() %>%
        .$data %>%
        subset(isTip) %>%
        .$label %>%
        na.omit()
      snp.dist <- snp.dist %>%
        mutate(iso1 = factor(iso1, levels = sample_order),
               iso2 = factor(iso2, levels = sample_order))
        
    }

    p_snp.dist <- ggplot(snp.dist, aes(x=iso1, y=iso2, fill=snps))+
      geom_tile()+
      geom_text(data=filter(snp.dist, snps < 100), aes(label=snps))+
      theme(axis.text.x = element_text(angle=90))+
      scale_fill_gradient(low = colors[3], high = "white")
    
    
    n_iso <- snp.dist$iso1 %>% unique() %>% length()
    if(n_iso > 10){
      wdth <- 1.3*n_iso
      hght <- 1.25*n_iso
    }else{
      wdth <- 10
      hght <- 8.5
    }
    
    ggsave(filename = paste0(matrix_file,".jpg"), plot = p_snp.dist, dpi = 300, width = wdth, height = hght, limitsize = F)
  }
}

display_matrix <- function(matrix_file){
  image_file <- paste0(matrix_file,".jpg")
  if(file.exists(image_file)){
    cat(paste0("![](",image_file,")"), sep="\n")
  }
}

# Linkage Summary Report
get_linkages <- function(matrix_file, strong, intermediate){
  # check if the file exists
  if(file.exists(matrix_file)){
    # print header
    cat("\n## Linkage Summary", sep = "\n")
    # read SNP matrix file and convert to long format
    snp.dist <- read_tsv(matrix_file) %>%
      pivot_longer(names_to = "ID2", values_to = "snps", cols = 2:ncol(.))
    colnames(snp.dist) <- c("ID1","ID2","snps")
    # identify linkages for each sample ID
    subfun <- function(id){
      # strong linkages
      strong_link <- snp.dist %>%
        subset(ID1 == id) %>%
        subset(ID1 != ID2) %>%
        subset(snps <= as.numeric(strong))
      if(nrow(strong_link > 0)){
        strong_result <- paste(strong_link$ID2, collapse = ", ")
        }else(strong_result <- "none")
      
      # intermediate linkages
      int_link <- snp.dist %>%
        subset(ID1 == id) %>%
        subset(ID1 != ID2) %>%
        subset(snps > as.numeric(strong) & snps <= as.numeric(intermediate))
      if(nrow(int_link > 0)){
        int_result <- paste(int_link$ID2, collapse = ", ")
        }else(int_result <- "none")
      
      # consolidate results
      strong_name <- paste0("Strong Linkage\n(within ",strong," SNPs)")
      inter_name <- paste0("Intermediate Linkage\n(within ",intermediate," SNPs)")
      result <- data.frame("ID" = id, "STRONG_LINKAGE" = strong_result, "INTER_LINKAGE" = int_result)
      colnames(result) <- c("ID", strong_name, inter_name)
      return(result)
    }
    
    # create list of samples to loop over, excluding the clade references and the snp reference
    id_list <- snp.dist %>% 
      subset(ID1 != "reference") %>% 
      subset(!(ID1 %in% meta.clades$sample)) %>%
      .$ID1 %>%
      unique()
    
    # combine outputs into a single table
    linkages <- do.call(rbind, lapply(id_list, FUN=subfun)) %>% rename(`Sample Name` = ID)
    # write to comma-separated file
    write.csv(x = linkages, file = "linkage_summary.csv", quote = F, row.names = F)
    # report
    linkages %>%
      kable(booktabs=T) %>%
      kable_styling(latex_options=c("striped","scale_down","hold_position"))
  }
}

# Clade Summary Report
determine_clade <- function(matrix_file){
  # check if the file exists
  if(file.exists(matrix_file)){
    # read SNP matrix file and convert to long format
    snp.dist <- read_tsv(matrix_file) %>%
      pivot_longer(names_to = "sample", values_to = "snps", cols = 2:ncol(.))
    colnames(snp.dist) <- c("ID","sample","snps")
    # add clade information
    snp.dist <- snp.dist %>%
      merge(meta.clades, by = "sample")
    # only run if clade references were included
    if(nrow(snp.dist) > 0){
        # create header
        cat("\n## Clade Assignment", sep = "\n")
        # identify linkages for each sample ID
        subfun <- function(id){
          result <- snp.dist %>%
            subset(ID == id) %>%
            subset(sample %in% meta.clades$sample) %>%
            subset(snps == min(snps)) %>%
            select(ID, clade, snps) %>%
            rename("Sample Name" = ID,
                   "Closest Clade" = clade, 
                   "SNP Differences" = snps)
          if(nrow(result) != 1){
            result <- data.frame("Sample Name" = id,
                                 "Closet Clade" = "Undetermined",
                                 "SNP Differences" = NA)
          }
          
          return(result)
        }
        
        # create list of samples to loop over, excluding the clade references and the snp reference
        id_list <- snp.dist %>% 
          subset(ID != "reference") %>% 
          subset(!(ID %in% meta.clades$sample)) %>%
          .$ID %>%
          unique()
        
        # combine outputs into a single table
        clades <- do.call(rbind, lapply(id_list, FUN=subfun))
        # write to comma-separated file
        write.csv(x = clades, file = "clade_summary.csv", quote = F, row.names = F)
        # report
        clades %>%
          kable(booktabs=T, row.names = F) %>%
          kable_styling(latex_options=c("striped","scale_down","hold_position"))
      }
    }
    
}

# SnpEff Summary Report
snpeff_report <- function(report_file){
  if(file.exists(report_file)){
    # create header
    cat("\n## FKS1 Variant Report", sep = "\n")
    # read report
    df <- read.csv(report_file)
    # check if variants were detected
    if(nrow(df) > 0){
      # remove clade references if present
      df <- df %>%
        subset(!(sample_id %in% meta.clades$sample))
      # check again that variants are still detected
      if(nrow(df) > 0){
        colnames(df) <- colnames(df) %>% str_replace_all(pattern = "_", replacement = " ") %>%
          str_replace_all(pattern = "id", replacement = "name") %>%
          str_to_title()
        df %>%
          kable(booktabs=T) %>%
          footnote("Only samples with detected variants are reported.") %>%
          kable_styling(latex_options=c("striped","scale_down","hold_position"))
      }else(cat("No variants detected", sep = "\n"))
    }else(cat("No variants detected", sep = "\n"))
  }
}
```

```{r, results='asis', echo=FALSE, message=FALSE, warning=FALSE}
# report sample QC
if(file.exists(qcreport_file)){
  cat("## Sequence Quality Report", sep = "\n")
  display_qc(qcreport_file)
}
```
\newpage  

\FloatBarrier

```{r, results='asis', echo=FALSE, message=FALSE, warning=FALSE}
# report trees
if(sum(file.exists(tree_files)) > 1){
  cat("## Phylogenetic Trees", sep = "\n")
  dev_null <- lapply(tree_files, FUN = make_tree) %>% unlist()
  dev_null <- lapply(tree_files, FUN = display_tree) %>% unlist()
}
```
\newpage  

\FloatBarrier

```{r, results='asis', echo=FALSE, message=FALSE, warning=FALSE}
# report SNP matrix
if(file.exists(snpmat_file)){
  cat("\n## SNP Distance Matrix", sep = "\n")
  make_matrix(matrix_file = snpmat_file, tree_files = tree_files)
  display_matrix(matrix_file = snpmat_file)
}
```
\newpage  

\FloatBarrier

```{r, results='asis', echo=FALSE, message=FALSE, warning=FALSE}
# report clades
if(file.exists(snpmat_file)){
  # the function only produces output if clade references were included in the analysis
  determine_clade(snpmat_file)
}
```
\newpage  

\FloatBarrier

```{r, results='asis', echo=FALSE, message=FALSE, warning=FALSE}
# report FSK1 mutations
if(file.exists(snpeff_file)){
  snpeff_report(snpeff_file)
}
```
\newpage  

\FloatBarrier

```{r, results='asis', echo=FALSE, message=FALSE, warning=FALSE}
# report linkages
if(file.exists(snpmat_file)){
  get_linkages(snpmat_file, strong = 10, intermediate = 50)
}
```
